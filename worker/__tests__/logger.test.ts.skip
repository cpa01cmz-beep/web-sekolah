import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { debug, info, warn, error, createChildLogger, logger, resetForTesting } from '../logger';

describe('Logger (Worker)', () => {
  let mockConsoleDebug: any;
  let mockConsoleInfo: any;
  let mockConsoleWarn: any;
  let mockConsoleError: any;

  beforeEach(() => {
    delete process.env.LOG_LEVEL;
    resetForTesting();

    mockConsoleDebug = vi.fn();
    mockConsoleInfo = vi.fn();
    mockConsoleWarn = vi.fn();
    mockConsoleError = vi.fn();

    console.debug = mockConsoleDebug;
    console.log = mockConsoleInfo;
    console.warn = mockConsoleWarn;
    console.error = mockConsoleError;
  });

  afterEach(() => {
    delete process.env.LOG_LEVEL;
    vi.restoreAllMocks();
  });

  describe('debug', () => {
    it('should log debug messages', () => {
      debug('Test debug message', { userId: '123' });

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Test debug message',
        context: { userId: '123' }
      });
    });

    it('should log debug messages without context', () => {
      debug('Test debug message');

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Test debug message'
      });
    });

    it('should handle context with multiple fields', () => {
      debug('Test message', { userId: '123', action: 'login', timestamp: '2026-01-07' });

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Test message',
        context: { userId: '123', action: 'login', timestamp: '2026-01-07' }
      });
    });
  });

  describe('info', () => {
    it('should log info messages', () => {
      info('User logged in', { userId: '123', email: 'user@example.com' });

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: 'User logged in',
        context: { userId: '123', email: 'user@example.com' }
      });
    });

    it('should log info messages without context', () => {
      info('Application started');

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: 'Application started'
      });
    });
  });

  describe('warn', () => {
    it('should log warning messages', () => {
      warn('Cache miss', { key: 'user:123' });

      expect(mockConsoleWarn).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleWarn.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'warn',
        message: 'Cache miss',
        context: { key: 'user:123' }
      });
    });

    it('should log warning messages without context', () => {
      warn('Deprecated API usage');

      expect(mockConsoleWarn).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleWarn.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'warn',
        message: 'Deprecated API usage'
      });
    });
  });

  describe('error', () => {
    it('should log error messages with Error object', () => {
      const testError = new Error('Test error');
      error('API request failed', testError, { endpoint: '/api/users' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'API request failed',
        context: {
          endpoint: '/api/users',
          error: {
            message: 'Test error',
            stack: testError.stack,
            name: 'Error'
          }
        }
      });
    });

    it('should log error messages without error object', () => {
      error('Something went wrong', undefined, { userId: '123' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Something went wrong',
        context: { userId: '123' }
      });
    });

    it('should log error messages without context', () => {
      const testError = new Error('Test error');
      error('Failed to fetch', testError);

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Failed to fetch',
        context: {
          error: {
            message: 'Test error',
            stack: testError.stack,
            name: 'Error'
          }
        }
      });
    });

    it('should handle non-Error error objects', () => {
      error('Error occurred', { customError: 'Custom error message' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Error occurred',
        context: {
          error: { customError: 'Custom error message' }
        }
      });
    });

    it('should handle null error value', () => {
      error('Error occurred', null, { userId: '123' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Error occurred',
        context: { userId: '123', error: null }
      });
    });

    it('should combine error object and context', () => {
      const testError = new Error('Database connection failed');
      error('Database error', testError, { query: 'SELECT * FROM users' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Database error',
        context: {
          query: 'SELECT * FROM users',
          error: {
            message: 'Database connection failed',
            stack: testError.stack,
            name: 'Error'
          }
        }
      });
    });
  });

  describe('createChildLogger', () => {
    it('should create child logger with context', () => {
      const childLogger = createChildLogger({ requestId: 'req-123', userId: 'user-456' });
      expect(childLogger).toBeDefined();
      expect(childLogger.debug).toBeTypeOf('function');
      expect(childLogger.info).toBeTypeOf('function');
      expect(childLogger.warn).toBeTypeOf('function');
      expect(childLogger.error).toBeTypeOf('function');
    });

    it('should use child logger for debug messages', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      childLogger.debug('Processing request');

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Processing request',
        context: { requestId: 'req-123' }
      });
    });

    it('should use child logger for info messages', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      childLogger.info('Request completed');

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: 'Request completed',
        context: { requestId: 'req-123' }
      });
    });

    it('should use child logger for warn messages', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      childLogger.warn('Slow request');

      expect(mockConsoleWarn).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleWarn.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'warn',
        message: 'Slow request',
        context: { requestId: 'req-123' }
      });
    });

    it('should use child logger for error messages with Error object', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      const testError = new Error('Processing failed');
      childLogger.error('Request failed', testError);

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Request failed',
        context: {
          requestId: 'req-123',
          error: {
            message: 'Processing failed',
            stack: testError.stack,
            name: 'Error'
          }
        }
      });
    });

    it('should allow child logger to add additional context', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      childLogger.info('Processing', { step: 'validation' });

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: 'Processing',
        context: { requestId: 'req-123', step: 'validation' }
      });
    });

    it('should allow child logger error to add additional context', () => {
      const childLogger = createChildLogger({ requestId: 'req-123' });
      const testError = new Error('Step failed');
      childLogger.error('Step error', testError, { step: 'validation' });

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Step error',
        context: {
          requestId: 'req-123',
          step: 'validation',
          error: {
            message: 'Step failed',
            stack: testError.stack,
            name: 'Error'
          }
        }
      });
    });
  });

  describe('logger export', () => {
    it('should export logger object with all methods', () => {
      expect(logger).toBeDefined();
      expect(logger.debug).toBe(debug);
      expect(logger.info).toBe(info);
      expect(logger.warn).toBe(warn);
      expect(logger.error).toBe(error);
    });

    it('should allow using logger object', () => {
      logger.debug('Debug via logger');
      logger.info('Info via logger');
      logger.warn('Warn via logger');
      logger.error('Error via logger');

      expect(mockConsoleDebug).toHaveBeenCalled();
      expect(mockConsoleInfo).toHaveBeenCalled();
      expect(mockConsoleWarn).toHaveBeenCalled();
      expect(mockConsoleError).toHaveBeenCalled();
    });
  });

  describe('log level from environment', () => {
    it('should use debug level when LOG_LEVEL=debug', () => {
      process.env.LOG_LEVEL = 'debug';
      resetForTesting();
      debug('Test message');

      expect(mockConsoleDebug).toHaveBeenCalled();
    });

    it('should use info level when LOG_LEVEL=info', () => {
      process.env.LOG_LEVEL = 'info';
      resetForTesting();
      debug('Test message');
      debug('Test message 2');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).toHaveBeenCalledTimes(2);
    });

    it('should use warn level when LOG_LEVEL=warn', () => {
      process.env.LOG_LEVEL = 'warn';
      resetForTesting();
      debug('Test message');
      info('Test message 2');
      warn('Test message 3');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).not.toHaveBeenCalled();
      expect(mockConsoleWarn).toHaveBeenCalledTimes(1);
    });

    it('should use error level when LOG_LEVEL=error', () => {
      process.env.LOG_LEVEL = 'error';
      resetForTesting();
      debug('Test message');
      info('Test message 2');
      warn('Test message 3');
      error('Test message 4');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).not.toHaveBeenCalled();
      expect(mockConsoleWarn).not.toHaveBeenCalled();
      expect(mockConsoleError).toHaveBeenCalledTimes(1);
    });

    it('should default to info when LOG_LEVEL is not set', () => {
      resetForTesting();
      debug('Test message');
      info('Test message 2');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).toHaveBeenCalledTimes(1);
    });

    it('should default to info when LOG_LEVEL is invalid', () => {
      process.env.LOG_LEVEL = 'invalid';
      resetForTesting();
      debug('Test message');
      info('Test message 2');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).toHaveBeenCalledTimes(1);
    });
  });

  describe('timestamp formatting', () => {
    it('should include ISO timestamp in log entries', () => {
      info('Test message');

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toHaveProperty('timestamp');
      expect(loggedData.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });
  });

  describe('edge cases', () => {
    it('should handle empty context object', () => {
      debug('Test message', {});

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Test message'
      });
    });

    it('should handle context with null values', () => {
      debug('Test message', { userId: null, action: undefined });

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Test message',
        context: { userId: null, action: undefined }
      });
    });

    it('should handle context with nested objects', () => {
      const context = {
        user: { id: '123', name: 'John' },
        meta: { timestamp: '2026-01-07', source: 'api' }
      };
      info('Complex context', context);

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: 'Complex context',
        context: context
      });
    });

    it('should handle error with missing stack property', () => {
      const errorWithoutStack = new Error('Test error');
      delete (errorWithoutStack as any).stack;

      error('Error without stack', errorWithoutStack);

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Error without stack',
        context: {
          error: {
            message: 'Test error',
            stack: undefined,
            name: 'Error'
          }
        }
      });
    });

    it('should handle Error subclasses', () => {
      class CustomError extends Error {
        constructor(message: string) {
          super(message);
          this.name = 'CustomError';
        }
      }

      const customError = new CustomError('Custom error occurred');
      error('Custom error', customError);

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Custom error',
        context: {
          error: {
            message: 'Custom error occurred',
            stack: customError.stack,
            name: 'CustomError'
          }
        }
      });
    });

    it('should handle error with undefined stack', () => {
      const errorWithUndefinedStack = new Error('Test error');
      (errorWithUndefinedStack as any).stack = undefined;

      error('Error with undefined stack', errorWithUndefinedStack);

      expect(mockConsoleError).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleError.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'error',
        message: 'Error with undefined stack',
        context: {
          error: {
            message: 'Test error',
            stack: undefined,
            name: 'Error'
          }
        }
      });
    });

    it('should handle context with arrays', () => {
      const context = {
        ids: ['1', '2', '3'],
        names: ['Alice', 'Bob']
      };
      debug('Array context', context);

      expect(mockConsoleDebug).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleDebug.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'debug',
        message: 'Array context',
        context: context
      });
    });

    it('should handle very long messages', () => {
      const longMessage = 'a'.repeat(10000);
      info(longMessage);

      expect(mockConsoleInfo).toHaveBeenCalled();
      const loggedData = JSON.parse(mockConsoleInfo.mock.calls[0][0]);
      expect(loggedData).toMatchObject({
        level: 'info',
        message: longMessage
      });
    });
  });
});
